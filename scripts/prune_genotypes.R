library(BEDMatrix)
library(RcppML)
library(extraDistr)
library(tidyverse)
library(ggpubr)
library(GGally)

# g is a matrix (n x s , n markers by s strains)
# t1 is a vector alternate allele counts  (n x 1 , n markers)

setwd(glue::glue("{dirname(rstudioapi::getActiveDocumentContext()$path)}/.."))

# load the output from "process_genotypes_n_counts.R"
load(file="temp/test_gPruned_and_prASER.Rdata")

####################################################
#################################################### 
#################################################### - apply filters to the genotypes

genotype_calls_vcf <- data.table::fread("data/WI.20210121.hard-filter_allele_counts.tsv.gz",
                                        col.names = c("chrom","pos","ref","alt","ac","an"))

# remove sites that are not variable in the mapping population
# remove sites that are not genotyped in a user-defined number of CeNDR isolates
# genotypes is a sites (row) x strain (column) matrix
# vcf_stats is a data frame with columns c("chrom","pos","ref","alt","ac","an"), generated by bcftools query
# # # bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\t%AC\t%AN\n' WI.20210121.hard-filter.isotype_with_cM.vcf.gz > WI.20210121.hard-filter.isotype_with_cM_allele_counts.tsv
# vcf_gt_rate is a number corresponding to the minimum number of allowed genotype calls in the CeNDR VCF to include the site as good for NNLS

g_filters <- function(genotypes, 
                      vcf_stats, 
                      vcf_gt_rate = 1000 ){
  
  af_matrix <- data.frame(marker = row.names(genotypes), af = rowSums(genotypes, na.rm = T)/ncol(genotypes))
  
  variant_sites_inpop <- af_matrix %>%
    dplyr::filter(af>0)
  
  genotypes_variantSites <- genotypes[row.names(genotypes) %in% variant_sites_inpop$marker,]
  
  # only consider markers with high genotyping rate in the CeNDR collection
  hi_gt_rate_markers <- vcf_stats %>%
    dplyr::filter(an>vcf_gt_rate, # most strains have genotype information
                  nchar(ref) == nchar(alt),
                  nchar(ref) == 1) %>% # not indels 
    tidyr::unite(marker, chrom, pos, sep = ":", remove = F) %>%
    tidyr::unite(marker, marker, alt, sep = "_") %>%
    dplyr::pull(marker)
  
  genotypes_variantSites_high_gt <- genotypes_variantSites[row.names(genotypes_variantSites) %in% hi_gt_rate_markers, ]
  
  return(genotypes_variantSites_high_gt)
}

####################################################
#################################################### 
#################################################### - flip coding of common alleles in genotype matrix and the alt count data

# function takes genotype matrix and allele counts as inputs
# takes any alleles that have > 50% allele frequency in the experimental population and flips their coding
# then formats that genotype matrix and allele counts for strain frequency inference
flip_common_variants <- function(genotypes, allele_counts){
  
  # find high frequency variants
  af_matrix <- data.frame(marker = row.names(genotypes), af = rowSums(genotypes, na.rm =T)/ncol(genotypes))
  
  high_alt <- af_matrix %>%
    dplyr::filter(af>0.5)
  
  # flip coding of high frequency variants
  g_changed <- genotypes[row.names(genotypes) %in% high_alt$marker,]
  
  g_changed <- abs(g_changed-1)
  
  # extract unchanged genotypes
  g_not_changed <- genotypes[!(row.names(genotypes) %in% high_alt$marker),]
  
  # append unchanged and flipped genotypes
  g_modified <- rbind(g_not_changed,g_changed)
  
  # Flip high frequency counts, spread alt calls, and sort by marker
  flip_high_alt_counts <- pr_alt_df_bias %>%
    dplyr::mutate(alt_count = ifelse(marker %in% high_alt$marker, dp-alt_ct, alt_ct)) %>%
    dplyr::select(marker, sample, alt_count) %>%
    dplyr::filter(marker %in% row.names(g_modified)) %>%
    tidyr::spread(sample, alt_count) %>%
    tidyr::separate(marker, into = c("chrom","pos","alt"), convert = T, remove = F) %>%
    dplyr::arrange(chrom, pos)

  # probably redundant, but filter modified matrix to match alt counts
  g_final <- g_modified[row.names(g_modified) %in% (flip_high_alt_counts$marker),]
  
  # resort genotypes and put back into a matrix
  g_resort <- g_final %>%
    as.data.frame() %>%
    tibble::rownames_to_column(var="marker") %>%
    tidyr::separate(marker, into = c("chrom","pos","alt"), convert = T, remove = F) %>%
    dplyr::arrange(chrom, pos) %>%
    dplyr::select(-(chrom:alt)) %>%
    tibble::column_to_rownames(var = "marker") %>%
    as.matrix()
  
  if(identical(flip_high_alt_counts$marker, row.names(g_resort))){
    
    t1m <- dplyr::select(flip_high_alt_counts, -marker, -chrom, -pos, -alt) %>%
      as.matrix()
    
    g_resort[is.na(g_resort)] <- 0
    
    g_n_counts <- list(g_resort,t1m)
    
    return(g_n_counts)
  } else{
    print("counts and g dont match")
    return(NULL)
  }
  
}

# rerun because NAs were switched to 0s above
g_variable_hiGT <- g_filters(genotypes = g_pruned,
                             vcf_stats = genotype_calls_vcf,
                             vcf_gt_rate = 1000)

allele_counts_variable_hiGT <- pr_alt_df_bias %>%
  dplyr::filter(marker %in% row.names(g_variable_hiGT))

flipped_bootstrap_input <- flip_common_variants(genotypes = g_variable_hiGT, 
                                                allele_counts = allele_counts_variable_hiGT)

# flipped_bootstrap_input[[1]] - genotype matrix
# flipped_bootstrap_input[[2]] - allele counts

save(flipped_bootstrap_input, file="temp/prunedGenotypes_FlipCommonVariants.RData")
